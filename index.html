<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>2D RPG â€“ Polished Visuals</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    canvas { display:block; margin:0 auto; background:#000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="512" height="384"></canvas>
  <script>
  const TILE_SIZE = 32;
  const MAP = [
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
    [1,0,0,2,0,0,0,3,0,0,0,2,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,3,3,3,0,0,3,0,0,3,3,3,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,0,0,0,0,0,0,3,0,0,0,0,0,0,0,1],
    [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
  ];
  const canvas = document.getElementById('gameCanvas'),
        ctx    = canvas.getContext('2d'),
        W      = canvas.width,
        H      = canvas.height;

  // Generate a 5-tile tileset: floor(0), wall(1), door(2), water0(3), water1(4)
  function createTileset() {
    const frames = 5, cvs = document.createElement('canvas');
    cvs.width = TILE_SIZE * frames; cvs.height = TILE_SIZE;
    const g = cvs.getContext('2d');

    // 0: floor
    g.fillStyle = '#88cc88';
    g.fillRect(0,0,TILE_SIZE,TILE_SIZE);
    g.fillStyle = '#77bb77';
    for(let i=0;i<6;i++) g.fillRect(Math.random()*(TILE_SIZE-2),Math.random()*(TILE_SIZE-2),2,2);

    // 1: wall
    const x1 = TILE_SIZE;
    g.fillStyle = '#999';
    g.fillRect(x1,0,TILE_SIZE,TILE_SIZE);
    g.fillStyle = '#666';
    for(let y=0;y<TILE_SIZE;y+=8)for(let x=0;x<TILE_SIZE;x+=8)
      g.fillRect(x1+x+1,y+1,6,6);

    // 2: door
    const x2 = TILE_SIZE*2;
    g.fillStyle = '#8b4513';
    g.fillRect(x2,0,TILE_SIZE,TILE_SIZE);
    g.fillStyle = '#553311';
    g.fillRect(x2+TILE_SIZE*0.2, TILE_SIZE*0.1, TILE_SIZE*0.6, TILE_SIZE*0.8);

    // 3 & 4: animated water
    for(let f=0;f<2;f++){
      const x = TILE_SIZE * (3+f);
      // base
      g.fillStyle = '#3377cc'; g.fillRect(x,0,TILE_SIZE,TILE_SIZE);
      // waves
      g.strokeStyle = 'rgba(255,255,255,0.5)';
      g.lineWidth = 2;
      g.beginPath();
      for(let i=-1;i<=TILE_SIZE;i+=8){
        g.moveTo(x-4, i + (f*4));
        g.quadraticCurveTo(x+TILE_SIZE/2, i+4 + (f*4), x+TILE_SIZE+4, i + (f*4));
      }
      g.stroke();
    }

    const img = new Image();
    img.src = cvs.toDataURL();
    return img;
  }

  // Generate a 4-frame player sprite sheet
  function createPlayerSheet() {
    const frames = 4, c = TILE_SIZE, cvs = document.createElement('canvas');
    cvs.width = c*frames; cvs.height = c;
    const g = cvs.getContext('2d');
    for(let f=0;f<frames;f++){
      const x0 = f * c;
      // body
      g.fillStyle = 'crimson';
      g.fillRect(x0+8, 8, 16, 16);
      // head
      g.fillStyle = '#000';
      g.fillRect(x0+12,4,8,8);
      // legs
      g.fillStyle = 'crimson';
      const offset = (f%2)?2:-2;
      g.fillRect(x0+10,24+offset,4,8);
      g.fillRect(x0+18,24-offset,4,8);
    }
    const img = new Image();
    img.src = cvs.toDataURL();
    return img;
  }

  const tilesetImg  = createTileset(),
        playerSheet = createPlayerSheet();

  let player = { x: TILE_SIZE*1.5, y: TILE_SIZE*1.5 },
      lastTime = 0;

  function drawBackground() {
    // simple vertical gradient sky
    const grad = ctx.createLinearGradient(0,0,0,H);
    grad.addColorStop(0, '#a0d8f1');
    grad.addColorStop(1, '#508dcf');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,W,H);
  }

  function draw(ts) {
    // clear
    drawBackground();

    // draw map
    MAP.forEach((row,y)=>{
      row.forEach((id,x)=>{
        let sx = id * TILE_SIZE;
        if(id === 3) {
          // water: alternate between frame 3 and 4 every 500ms
          const frame = Math.floor(ts/500)%2;
          sx = (3+frame)*TILE_SIZE;
        }
        ctx.drawImage(
          tilesetImg,
          sx, 0, TILE_SIZE, TILE_SIZE,
          x*TILE_SIZE, y*TILE_SIZE, TILE_SIZE, TILE_SIZE
        );
      });
    });

    // draw player animation
    const pf = Math.floor(ts/150)%4;
    ctx.drawImage(
      playerSheet,
      pf*TILE_SIZE,0,TILE_SIZE,TILE_SIZE,
      player.x - TILE_SIZE/2, player.y - TILE_SIZE/2,
      TILE_SIZE, TILE_SIZE
    );

    requestAnimationFrame(draw);
  }

  window.addEventListener('keydown', e=>{
    const S = TILE_SIZE;
    if(e.key==='ArrowUp')    player.y -= S;
    else if(e.key==='ArrowDown')  player.y += S;
    else if(e.key==='ArrowLeft')  player.x -= S;
    else if(e.key==='ArrowRight') player.x += S;
    // clamp
    player.x = Math.max(S/2, Math.min(W-S/2, player.x));
    player.y = Math.max(S/2, Math.min(H-S/2, player.y));
  });

  // kick off
  requestAnimationFrame(draw);
  </script>
</body>
</html>
