<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>2D RPG with Animated Sprite</title>
  <style>
    body { margin:0; overflow:hidden; background:#000; }
    #gameCanvas { display:block; margin:0 auto; background:#000; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="512" height="384"></canvas>
  <script>
    const TILE_SIZE = 32;
    // Simple 16×12 map: 0=floor, 1=wall, 2=door
    const MAP = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,2,0,0,0,0,0,0,0,2,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    const canvas = document.getElementById('gameCanvas');
    const ctx    = canvas.getContext('2d');

    // Player “center” position
    const player = { x: TILE_SIZE * 1.5, y: TILE_SIZE * 1.5 };

    // Generate a 4-frame sprite sheet in-memory
    function generateSpriteSheet(color) {
      const frames = 4, c = TILE_SIZE, cvs = document.createElement('canvas');
      cvs.width = c * frames; cvs.height = c;
      const g = cvs.getContext('2d');
      for (let f = 0; f < frames; f++) {
        const x0 = f * c;
        // torso
        g.fillStyle = color;
        g.fillRect(x0 + 8, 8, 16, 16);
        // head
        g.fillStyle = '#000';
        g.fillRect(x0 + 12, 4, 8, 8);
        // legs alternate frames
        g.fillStyle = color;
        if (f % 2 === 0) {
          g.fillRect(x0 + 10, 24, 4, 8);
          g.fillRect(x0 + 18, 24, 4, 8);
        } else {
          g.fillRect(x0 + 8, 24, 4, 8);
          g.fillRect(x0 + 20, 24, 4, 8);
        }
      }
      const img = new Image();
      img.src = cvs.toDataURL();
      return img;
    }

    // Create the player sprite sheet
    const playerSheet = generateSpriteSheet('crimson');

    // Draw the static map once into an off-screen canvas for speed
    const mapCanvas = document.createElement('canvas');
    mapCanvas.width  = canvas.width;
    mapCanvas.height = canvas.height;
    const mapCtx = mapCanvas.getContext('2d');
    MAP.forEach((row, y) => {
      row.forEach((id, x) => {
        switch (id) {
          case 0: mapCtx.fillStyle = '#8FBC8F'; break; // floor
          case 1: mapCtx.fillStyle = '#555';    break; // wall
          case 2: mapCtx.fillStyle = '#8B4513'; break; // door
        }
        mapCtx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
      });
    });

    // Draw frame `f` of the player
    function drawScene(frame) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // draw map
      ctx.drawImage(mapCanvas, 0, 0);
      // draw player sprite (centered)
      ctx.drawImage(
        playerSheet,
        frame * TILE_SIZE, 0, TILE_SIZE, TILE_SIZE,
        player.x - TILE_SIZE / 2,
        player.y - TILE_SIZE / 2,
        TILE_SIZE,
        TILE_SIZE
      );
    }

    // Animation loop
    function loop(ts) {
      const frame = Math.floor(ts / 150) % 4;
      drawScene(frame);
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // Handle arrow-key movement
    window.addEventListener('keydown', e => {
      const step = TILE_SIZE;
      if (e.key === 'ArrowUp')    player.y -= step;
      else if (e.key === 'ArrowDown')  player.y += step;
      else if (e.key === 'ArrowLeft')  player.x -= step;
      else if (e.key === 'ArrowRight') player.x += step;
      // clamp to bounds
      player.x = Math.max(step/2, Math.min(canvas.width - step/2, player.x));
      player.y = Math.max(step/2, Math.min(canvas.height - step/2, player.y));
    });
  </script>
</body>
</html>
