<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>2D RPG Engine with Graphics</title>
  <style>
    body{margin:0;overflow:hidden;background:#000;}
    #gameContainer{position:relative;width:512px;height:384px;margin:0 auto;overflow:hidden;}
    canvas{display:block;}
    /* Overlays hidden by default */
    #battleUI, #dialogueBox, #questLog {
      display:none;
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      font-family:Arial,sans-serif;
      color:#fff;
    }
    /* Show when active */
    #battleUI.active {
      display:flex;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.8);
    }
    #dialogueBox.active,
    #questLog.active {
      display:block;
    }
    /* Fade overlay */
    #fadeOverlay{
      position:absolute; top:0; left:0;
      width:100%; height:100%;
      background:#000; opacity:0;
      pointer-events:none;
      transition:opacity 500ms ease;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas" width="512" height="384"></canvas>
    <div id="fadeOverlay"></div>

    <!-- Battle UI -->
    <div id="battleUI">
      <canvas id="battleCanvas" width="512" height="384" style="background:#222;"></canvas>
      <div id="battleMenu" style="position:absolute;bottom:20px;left:50%;transform:translateX(-50%);">
        <ul id="menuOptions" style="list-style:none;padding:0;margin:0;">
          <li>▶ Attack</li><li>   Defend</li><li>   Item</li>
        </ul>
      </div>
    </div>

    <!-- Dialogue Box -->
    <div id="dialogueBox" style="
      bottom:20px; left:50%; transform:translateX(-50%);
      width:70%; background:rgba(0,0,0,0.8);
      padding:12px; border-radius:8px;
    ">
      <p id="dialogueText" style="margin:0 0 8px;"></p>
      <ul id="choiceList" style="list-style:none;padding:0;margin:0;"></ul>
    </div>

    <!-- Quest Log -->
    <div id="questLog" style="
      top:20px; right:20px; width:200px; max-height:70%;
      background:rgba(0,0,0,0.8); padding:12px;
      border-radius:8px; overflow-y:auto;
    ">
      <h3 style="margin:0 0 8px;">Quest Log</h3>
      <ul id="questList" style="list-style:none;padding:0;margin:0;"></ul>
    </div>
  </div>

  <script>
  (function(){
    const TILE_SIZE = 32,
          FPS       = 60,
          STEP      = 1000 / FPS;

    // ───────── Procedural Graphics ─────────
    function createTileset() {
      const c = document.createElement('canvas');
      c.width = TILE_SIZE * 3; c.height = TILE_SIZE;
      const o = c.getContext('2d');
      // Floor (0)
      o.fillStyle = '#88cc88'; o.fillRect(0, 0, TILE_SIZE, TILE_SIZE);
      o.fillStyle = '#77bb77';
      for (let i = 0; i < 6; i++) {
        o.fillRect(Math.random()*(TILE_SIZE-2), Math.random()*(TILE_SIZE-2), 2, 2);
      }
      // Wall (1)
      const x1 = TILE_SIZE;
      o.fillStyle = '#aaaaaa'; o.fillRect(x1, 0, TILE_SIZE, TILE_SIZE);
      o.fillStyle = '#888888';
      for (let y = 0; y < TILE_SIZE; y += 8) {
        for (let x = 0; x < TILE_SIZE; x += 8) {
          o.fillRect(x1 + x + 1, y + 1, 6, 6);
        }
      }
      // Door (2)
      const x2 = TILE_SIZE * 2;
      o.fillStyle = '#886633'; o.fillRect(x2, 0, TILE_SIZE, TILE_SIZE);
      o.fillStyle = '#553311';
      o.fillRect(x2 + TILE_SIZE * 0.2, TILE_SIZE * 0.1, TILE_SIZE * 0.6, TILE_SIZE * 0.8);

      return c.toDataURL();
    }
    function createPlayerSprite() {
      const sz = TILE_SIZE * 0.8;
      const c = document.createElement('canvas');
      c.width = sz; c.height = sz;
      const o = c.getContext('2d');
      o.fillStyle = 'crimson';
      o.beginPath();
      o.arc(sz/2, sz/2, sz/2, 0, Math.PI*2);
      o.fill();
      return c.toDataURL();
    }

    // ───────── Inline Map Data ─────────
    function genMap(w, h, doors) {
      const tiles = [];
      for (let y = 0; y < h; y++) {
        const row = [];
        for (let x = 0; x < w; x++) {
          let id = (x===0||y===0||x===w-1||y===h-1) ? 1 : 0; // border=wall
          doors.forEach(([dx,dy]) => { if(x===dx&&y===dy) id = 2; });
          row.push(id);
        }
        tiles.push(row);
      }
      return { width: w, height: h, tiles };
    }
    const MAPS = {
      town: genMap(16,12,[[3,2],[10,2]]),
      cave: genMap(16,12,[[1,1]]),
      shop: genMap(16,12,[[0,5]])
    };
    const DOORS = {
      town: { '3,2':{to:'cave',spawn:{x:1.5*TILE_SIZE,y:1.5*TILE_SIZE}},
              '10,2':{to:'shop',spawn:{x:2.5*TILE_SIZE,y:3.5*TILE_SIZE}} },
      cave: { '1,1':{to:'town',spawn:{x:3.5*TILE_SIZE,y:2.5*TILE_SIZE}} },
      shop: { '0,5':{to:'town',spawn:{x:10.5*TILE_SIZE,y:2.5*TILE_SIZE}} }
    };

    // ───────── DOM Refs ─────────
    const canvas    = document.getElementById('gameCanvas'),
          ctx       = canvas.getContext('2d'),
          fadeDiv   = document.getElementById('fadeOverlay'),
          container = document.getElementById('gameContainer'),
          battleUI  = document.getElementById('battleUI'),
          dialogueB = document.getElementById('dialogueBox'),
          questL    = document.getElementById('questLog'),
          battleMenu= document.getElementById('menuOptions'),
          dialogueText = document.getElementById('dialogueText'),
          choiceList   = document.getElementById('choiceList'),
          questList    = document.getElementById('questList');

    fadeDiv.style.transition    = `opacity 500ms ease`;
    container.style.transition  = `transform 500ms ease`;

    // ───────── MapLoader ─────────
    class MapLoader {
      constructor(ts,img,blocked,doors){ this.ts=ts; this.img=img; this.blocked=blocked; this.doors=doors; }
      draw(map,room){
        this.map=map; this.room=room;
        map.tiles.forEach((row,y) => row.forEach((id,x) => {
          ctx.drawImage(this.img, id*this.ts, 0, this.ts, this.ts,
                        x*this.ts, y*this.ts, this.ts, this.ts);
        }));
      }
      idAt(px,py){
        const tx=Math.floor(px/this.ts), ty=Math.floor(py/this.ts);
        if (tx<0||ty<0||tx>=this.map.width||ty>=this.map.height) return null;
        return this.map.tiles[ty][tx];
      }
      isBlocked(px,py){ return this.blocked(this.idAt(px,py)); }
      getTrigger(px,py){
        const tx=Math.floor(px/this.ts), ty=Math.floor(py/this.ts),
              key=`${tx},${ty}`,
              t=this.doors[this.room]||{};
        return t[key]||null;
      }
    }

    // ───────── NPC & Pathfinding ─────────
    class Pathfinder {
      constructor(m,b){this.w=m.width;this.h=m.height;this.t=m.tiles;this.b=b;}
      findPath(s,e){
        const ser=o=>`${o.x},${o.y}`,inB=o=>o.x>=0&&o.y>=0&&o.x<this.w&&o.y<this.h,
              walk=o=>!this.b(this.t[o.y][o.x]),
              nbrs=o=>[{x:o.x+1,y:o.y},{x:o.x-1,y:o.y},{x:o.x,y:o.y+1},{x:o.x,y:o.y-1}]
                        .filter(inB).filter(walk),
              h=o=>Math.abs(o.x-e.x)+Math.abs(o.y-e.y);
        let open=new Set([ser(s)]), came={}, g={ [ser(s)]:0 }, f={ [ser(s)]:h(s) };
        while(open.size){
          let ck,cf=1e9;
          for(let k of open) if((f[k]||1e9)<cf){cf=f[k];ck=k;}
          const [cx,cy]=ck.split(',').map(Number), cur={x:cx,y:cy};
          if(cx===e.x&&cy===e.y){
            const path=[]; let k=ck;
            while(k!==ser(s)){ const [px,py]=k.split(',').map(Number); path.push({x:px,y:py}); k=came[k]; }
            return path.reverse();
          }
          open.delete(ck);
          nbrs(cur).forEach(n=>{
            const nk=ser(n), ng=(g[ck]||0)+1;
            if(ng<(g[nk]||1e9)){ came[nk]=ck; g[nk]=ng; f[nk]=ng+h(n); open.add(nk); }
          });
        }
        return [];
      }
    }
    class NPC {
      constructor(name,pos,color){ this.name=name; this.x=pos.x; this.y=pos.y; this.color=color; this.path=[]; }
      step(map){ if(!this.path.length){
          const target={x:Math.floor(Math.random()*map.width),y:Math.floor(Math.random()*map.height)};
          this.path=new Pathfinder(map,id=>id===1).findPath({x:this.x,y:this.y},target);
        }
        if(this.path.length){ const n=this.path.shift(); this.x=n.x; this.y=n.y; }
      }
      draw(){ ctx.fillStyle=this.color;
        ctx.beginPath();
        ctx.arc(this.x*TILE_SIZE+TILE_SIZE/2, this.y*TILE_SIZE+TILE_SIZE/2, TILE_SIZE/3, 0, 2*Math.PI);
        ctx.fill();
      }
    }

    // ───────── Dialogue & Quests ─────────
    const DIALOGUES = {
      elder: {
        start:   { text:"Greetings! Help us find the Gem?", choices:[{text:"Yes",next:"accept"},{text:"No",next:"decline"}] },
        accept:  { text:"Thank you! Seek the Gem in the cave.", choices:[{text:"Onward",next:null}] },
        decline: { text:"Safe travels.", choices:[] }
      }
    };
    const QUESTS = {
      findGem: { title:"Find the Gem", status:"inactive", objectives:[{id:"gem",x:12,y:8,desc:"Locate Gem",done:false}] }
    };
    class DialogueManager {
      constructor(){
        this.box=document.getElementById('dialogueBox');
        this.txt=document.getElementById('dialogueText');
        this.lst=document.getElementById('choiceList');
        this.onKey=this._onKey.bind(this);
      }
      start(npc){
        this.data=DIALOGUES[npc]; this.node='start';
        this.box.classList.add('active'); this.render();
        window.addEventListener('keydown',this.onKey);
      }
      render(){
        const node=this.data[this.node];
        this.txt.textContent=node.text;
        this.lst.innerHTML='';
        node.choices.forEach((c,i)=>{
          const li=document.createElement('li');
          li.textContent=`${i+1}. ${c.text}`;
          this.lst.appendChild(li);
        });
      }
      _onKey(e){
        const idx=parseInt(e.key)-1, node=this.data[this.node];
        if(!isNaN(idx)&&node.choices[idx]){
          const next=node.choices[idx].next;
          window.removeEventListener('keydown',this.onKey);
          if(idx===0 && this.node==='start') questManager.activate('findGem');
          if(next){ this.node=next; this.render(); window.addEventListener('keydown',this.onKey); }
          else this.box.classList.remove('active');
        }
      }
    }
    class QuestManager {
      constructor(){
        this.log=document.getElementById('questLog');
        this.lst=document.getElementById('questList');
      }
      activate(id){
        const q=QUESTS[id]; if(q.status==='inactive'){ q.status='active'; this.update(); }
      }
      update(){
        this.lst.innerHTML='';
        Object.values(QUESTS).forEach(q=>{
          if(q.status!=='inactive'){
            const li=document.createElement('li');
            li.textContent=`${q.status==='completed'?'✔':'*'} ${q.title}`;
            this.lst.appendChild(li);
            q.objectives.forEach(o=>{
              const oli=document.createElement('li');
              oli.textContent=`  [${o.done?'✔':' '}] ${o.desc}`;
              this.lst.appendChild(oli);
            });
          }
        });
      }
      toggle(){
        this.log.classList.toggle('active');
      }
      complete(qid,obj){
        const q=QUESTS[qid];
        const o=q.objectives.find(x=>x.id===obj);
        if(o&&!o.done){ o.done=true; if(q.objectives.every(x=>x.done)) q.status='completed'; this.update(); }
      }
    }

    const dialogueManager=new DialogueManager();
    const questManager   =new QuestManager();
    window.addEventListener('keydown',e=>{ if(e.key==='q') questManager.toggle(); });

    // ───────── Battle Stub (hidden unless you press B) ─────────
    class BattleManager {
      constructor(){
        this.state='idle';
        this.ui=document.getElementById('battleUI');
        this.ctx=document.getElementById('battleCanvas').getContext('2d');
        this.menu=document.getElementById('menuOptions');
        this.opts=['Attack','Defend','Item'];
        this.sel=0;
        this.handle=this._onKey.bind(this);
      }
      start(){
        this.state='player'; this.sel=0;
        this.ui.classList.add('active'); this._updateMenu(); this._draw();
        window.addEventListener('keydown',this.handle);
      }
      _end(){ window.removeEventListener('keydown',this.handle); this.ui.classList.remove('active'); }
      _updateMenu(){
        this.menu.querySelectorAll('li').forEach((li,i)=>{
          li.textContent=(i===this.sel?'▶ ':'   ')+this.opts[i];
        });
      }
      _onKey(e){
        if(this.state!=='player') return;
        if(e.key==='ArrowUp'){ this.sel=(this.sel+3-1)%3; this._updateMenu(); }
        if(e.key==='ArrowDown'){ this.sel=(this.sel+1)%3; this._updateMenu(); }
        if(e.key==='Enter') this._act(this.opts[this.sel]);
      }
      _act(choice){
        // stub: just close
        this._end();
      }
      _draw(){
        this.ctx.clearRect(0,0,512,384);
        // stub: draw menu
      }
    }
    const battle = new BattleManager();
    window.addEventListener('keydown',e=>{
      if(e.key==='b' && battle.state==='idle') battle.start();
    });

    // ───────── Day/Night ─────────
    class DayNight {
      constructor(ms){ this.ms=ms; this.t=0; }
      update(dt){ this.t=(this.t+dt)%this.ms; }
      apply(ctx,can){
        const half=this.ms/2, v=this.t<half
          ? Math.sin((this.t/half)*Math.PI)
          : Math.sin(((this.t-half)/half)*Math.PI);
        ctx.fillStyle=`rgba(10,10,50,${(v*0.7).toFixed(3)})`;
        ctx.fillRect(0,0,can.width,can.height);
      }
    }
    const dayNight=new DayNight(120000);

    // ───────── Main Engine ─────────
    const tilesetImg = new Image();
    const playerImg  = new Image();
    tilesetImg.src = createTileset();
    playerImg.src  = createPlayerSprite();
    tilesetImg.onload = ()=>init();

    function fadeOut(){ return new Promise(r=>{ fadeDiv.style.opacity=1; fadeDiv.addEventListener('transitionend',r,{once:true}); }); }
    function fadeIn() { return new Promise(r=>{ fadeDiv.style.opacity=0; fadeDiv.addEventListener('transitionend',r,{once:true}); }); }
    function clamp(v,m,M){ return v<m?m:v>M?M:v; }

    let loader, room='town', map, player, npcs;
    async function init(){
      loader = new MapLoader(TILE_SIZE, tilesetImg, id=>id===1, DOORS);
      map    = MAPS[room];
      player = { x:1.5*TILE_SIZE, y:1.5*TILE_SIZE, w:0.8*TILE_SIZE, h:0.8*TILE_SIZE };
      npcs   = [ new NPC('elder',{x:4,y:2},'gold'), new NPC('shopkeeper',{x:10,y:2},'teal') ];

      await loadRoom(room, {x:player.x,y:player.y});
      requestAnimationFrame(loop);
      window.addEventListener('keydown',e=>{
        const M = {'ArrowUp':[0,-TILE_SIZE],'ArrowDown':[0,TILE_SIZE],'ArrowLeft':[-TILE_SIZE,0],'ArrowRight':[TILE_SIZE,0]}[e.key];
        if(M) tryMove(...M);
      });
    }

    async function loadRoom(r,spawn){
      await fadeOut();
      room = r; map = MAPS[r];
      loader.draw(map,room);
      if(spawn) { player.x=spawn.x; player.y=spawn.y; }
      await fadeIn();
    }

    function tryMove(dx,dy){
      const nx=player.x+dx, ny=player.y+dy,
            cx=nx+player.w/2, cy=ny+player.h/2;
      if(loader.isBlocked(cx,cy)) return;
      player.x=nx; player.y=ny;
      loader.draw(map,room);
      draw();
      const trg = loader.getTrigger(cx,cy);
      if(trg) loadRoom(trg.to, trg.spawn);
      // NPC chatter, quests, etc.
    }

    function draw(){
      ctx.clearRect(0,0,512,384);
      loader.draw(map,room);
      npcs.forEach(n=>{ n.step(map); n.draw(); });
      ctx.drawImage(playerImg, player.x, player.y, player.w, player.h);
      dayNight.apply(ctx, canvas);
    }

    let last=performance.now(),acc=0;
    function loop(now){
      const dt=Math.min(now-last,STEP*4);
      last=now; acc+=dt;
      while(acc>=STEP){ npcs.forEach(n=>n.step(map)); dayNight.update(STEP); acc-=STEP; }
      draw();
      requestAnimationFrame(loop);
    }
  })();
  </script>
</body>
</html>
